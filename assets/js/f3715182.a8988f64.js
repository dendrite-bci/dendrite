"use strict";(self.webpackChunkdendrite_docs=self.webpackChunkdendrite_docs||[]).push([[506],{919:(e,n,d)=>{d.r(n),d.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"api/generated/dendrite/ml/decoders/decoders","title":"dendrite.ml.decoders","description":"Dendrite Decoder Module","source":"@site/docs/api/generated/dendrite/ml/decoders/index.md","sourceDirName":"api/generated/dendrite/ml/decoders","slug":"/api/generated/dendrite/ml/decoders/","permalink":"/dendrite/docs/api/generated/dendrite/ml/decoders/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"decoders","sidebar_label":"decoders","title":"dendrite.ml.decoders"},"sidebar":"tutorialSidebar","previous":{"title":"event_outlet","permalink":"/dendrite/docs/api/generated/dendrite/data/event_outlet"},"next":{"title":"decoder","permalink":"/dendrite/docs/api/generated/dendrite/ml/decoders/decoder"}}');var s=d(4848),t=d(8453);const i={id:"decoders",sidebar_label:"decoders",title:"dendrite.ml.decoders"},l=void 0,c={},a=[{value:"create_decoder",id:"create_decoder",level:4},{value:"load_decoder",id:"load_decoder",level:4},{value:"validate_decoder_file",id:"validate_decoder_file",level:4},{value:"get_decoder_metadata",id:"get_decoder_metadata",level:4}];function o(e){const n={code:"code",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Dendrite Decoder Module"}),"\n",(0,s.jsx)(n.p,{children:"This module contains the main decoder implementation for brain-machine interface applications."}),"\n",(0,s.jsx)(n.p,{children:"The Decoder class supports both neural network and classical ML pipelines for\nEEG signal classification with an sklearn-compatible interface."}),"\n",(0,s.jsx)(n.h4,{id:"create_decoder",children:"create_decoder"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def create_decoder(model_type: str = "EEGNet", **kwargs)\n'})}),"\n",(0,s.jsx)(n.p,{children:"Create a Decoder instance using the complete decoder configuration."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"model_type"})," - Model architecture name ('EEGNet', 'TransformerEEG', 'LinearEEG', etc.)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"**kwargs"})," - Additional decoder config including num_classes, input_shapes,\nevent_mapping, label_mapping, epochs, learning_rate, etc."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"Configured Decoder instance ready for training."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"decoder = create_decoder(\n    model_type='EEGNet',\n    num_classes=3,\n    input_shapes=\\{'eeg': (32, 250)\\},\n    event_mapping=\\{1: 'left', 2: 'right'\\},\n    label_mapping=\\{'left': 0, 'right': 1\\}\n)\n"})}),"\n",(0,s.jsx)(n.h4,{id:"load_decoder",children:"load_decoder"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def load_decoder(decoder_path: str) -> Decoder\n"})}),"\n",(0,s.jsx)(n.p,{children:"Load a pre-trained decoder from a saved decoder file."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"decoder_path"})," - Path to the saved decoder JSON metadata file."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"Decoder instance with loaded weights/parameters ready for inference."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Raises"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FileNotFoundError"})," - If decoder file doesn't exist."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"RuntimeError"})," - If loading fails."]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"validate_decoder_file",children:"validate_decoder_file"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def validate_decoder_file(\n    filepath: str,\n    expected_shapes: dict[str, tuple[int, int]] | None = None,\n    expected_sample_rate: float | None = None,\n    expected_labels: dict[str, list[str]] | None = None\n) -> tuple[dict[str, Any] | None, list[str]]\n"})}),"\n",(0,s.jsx)(n.p,{children:"Validate decoder file with detailed error reporting."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"filepath"})," - Path to decoder JSON file or base path"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"expected_shapes"})," - Expected input shapes per modality: {'eeg': (channels, samples), ...}"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"expected_sample_rate"})," - Expected sampling rate in Hz"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"expected_labels"})," - Expected channel labels per modality: {'EEG': ['Fp1', 'Fp2', ...], ...}"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"Tuple of (metadata_dict or None, list of validation issues)"}),"\n",(0,s.jsx)(n.h4,{id:"get_decoder_metadata",children:"get_decoder_metadata"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def get_decoder_metadata(filepath: str) -> dict[str, Any]\n"})}),"\n",(0,s.jsx)(n.p,{children:"Get metadata from saved decoder file for inspection without loading."}),"\n",(0,s.jsx)(n.p,{children:"Use this to inspect decoder properties (model type, input shapes, class\nmappings, training info) without loading the full model weights."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"filepath"})," - Path to saved decoder JSON file."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,s.jsx)(n.p,{children:"Decoder metadata including model_type, input_shapes, num_classes,\nevent_mapping, label_mapping, and training configuration."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Raises"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"FileNotFoundError"})," - If file doesn't exist."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"ValueError"})," - If metadata validation fails."]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(o,{...e})}):o(e)}},8453:(e,n,d)=>{d.d(n,{R:()=>i,x:()=>l});var r=d(6540);const s={},t=r.createContext(s);function i(e){const n=r.useContext(t);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(t.Provider,{value:n},e.children)}}}]);