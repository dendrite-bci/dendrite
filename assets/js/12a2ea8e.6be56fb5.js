"use strict";(self.webpackChunkdendrite_docs=self.webpackChunkdendrite_docs||[]).push([[248],{2540:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>t,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"conceptual/architecture/ml-layer","title":"Machine Learning Layer","description":"PyTorch models with sklearn-compatible fit/predict interface for cross-validation and real-time inference.","source":"@site/docs/conceptual/architecture/ml-layer.md","sourceDirName":"conceptual/architecture","slug":"/conceptual/architecture/ml-layer","permalink":"/dendrite/docs/conceptual/architecture/ml-layer","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"ml-layer","title":"Machine Learning Layer","sidebar_label":"ML Layer"},"sidebar":"tutorialSidebar","previous":{"title":"Processing Layer","permalink":"/dendrite/docs/conceptual/architecture/processing-layer"},"next":{"title":"Auxiliary Layer","permalink":"/dendrite/docs/conceptual/architecture/auxiliary-layer"}}');var i=n(4848),c=n(8453);const t={id:"ml-layer",title:"Machine Learning Layer",sidebar_label:"ML Layer"},a="Machine Learning Layer",d={},l=[{value:"Decoders",id:"decoders",level:2},{value:"Neural Network Classifier",id:"neural-network-classifier",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Data Augmentation",id:"data-augmentation",level:3},{value:"Data Contracts",id:"data-contracts",level:3},{value:"Models",id:"models",level:2},{value:"Metrics",id:"metrics",level:2},{value:"Synchronous Metrics",id:"synchronous-metrics",level:3},{value:"Asynchronous Metrics",id:"asynchronous-metrics",level:3}];function o(e){const r={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,c.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.header,{children:(0,i.jsx)(r.h1,{id:"machine-learning-layer",children:"Machine Learning Layer"})}),"\n",(0,i.jsxs)(r.p,{children:["PyTorch models with sklearn-compatible ",(0,i.jsx)(r.code,{children:"fit"}),"/",(0,i.jsx)(r.code,{children:"predict"})," interface for cross-validation and real-time inference."]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Processing Flow:"})}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-text",children:"Preprocessed Data \u2192 Decoder Pipeline \u2192 Neural Network \u2192 Predictions\n   (array)           (NeuralNetClassifier)  (EEGNet/etc)  (labels + confidence)\n"})}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"decoders",children:"Decoders"}),"\n",(0,i.jsxs)(r.p,{children:["Decoder (",(0,i.jsx)(r.code,{children:"src/dendrite/ml/decoders/decoder.py"}),") wraps PyTorch models with sklearn-compatible methods (",(0,i.jsx)(r.code,{children:"fit"}),"/",(0,i.jsx)(r.code,{children:"predict"}),"/",(0,i.jsx)(r.code,{children:"predict_proba"}),") for offline training and real-time BCI inference."]}),"\n",(0,i.jsxs)(r.p,{children:["The decoder builds sklearn pipelines for both neural networks (NeuralNetClassifier) and classical ML (CSP spatial filtering with LDA/SVM). Both support the same interface, enabling offline cross-validation via StratifiedKFold and consistent training/inference for real-time sessions. All pipelines accept array input with shape ",(0,i.jsx)(r.code,{children:"(n_samples, n_channels, n_times)"}),"."]}),"\n",(0,i.jsx)(r.h3,{id:"neural-network-classifier",children:"Neural Network Classifier"}),"\n",(0,i.jsxs)(r.p,{children:["NeuralNetClassifier (",(0,i.jsx)(r.code,{children:"src/dendrite/ml/decoders/neural_classifier.py"}),") bridges PyTorch models and sklearn interfaces with training infrastructure including weighted loss for class imbalance, early stopping, auto device detection (CUDA/MPS/CPU), learning rate scheduling, and L2 regularization."]}),"\n",(0,i.jsx)(r.h3,{id:"configuration",children:"Configuration"}),"\n",(0,i.jsxs)(r.p,{children:["Decoders use Pydantic schemas (",(0,i.jsx)(r.code,{children:"src/dendrite/ml/decoders/decoder_schemas.py"}),") with two-level hierarchy: ",(0,i.jsx)(r.code,{children:"NeuralNetConfig"})," for training parameters (learning rate, batch size, regularization, early stopping) and ",(0,i.jsx)(r.code,{children:"DecoderConfig"})," extending it with decoder metadata (model_type, event/label mappings, input shapes). See ",(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/dendrite/docs/api/generated/dendrite/ml/decoders/decoder",children:"Decoders API"})})," for complete parameter reference."]}),"\n",(0,i.jsx)(r.h3,{id:"data-augmentation",children:"Data Augmentation"}),"\n",(0,i.jsxs)(r.p,{children:["Online augmentation applies random transformations during training to improve model generalization. Available strategies include noise injection, amplitude scaling, time/channel masking, and dropout. Presets (",(0,i.jsx)(r.code,{children:"light"}),", ",(0,i.jsx)(r.code,{children:"moderate"}),", ",(0,i.jsx)(r.code,{children:"aggressive"}),") configure strategy combinations and application probabilities. Mixup/CutMix augmentation also supported. Configure via ",(0,i.jsx)(r.code,{children:"use_augmentation"}),", ",(0,i.jsx)(r.code,{children:"aug_strategy"}),", and mixup parameters."]}),"\n",(0,i.jsx)(r.h3,{id:"data-contracts",children:"Data Contracts"}),"\n",(0,i.jsx)(r.p,{children:"Array-based data structures throughout the pipeline."}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Decoder Input"})}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"X: np.ndarray  # (n_samples, n_channels, n_times)\ny: np.ndarray  # (n_samples,) - class labels for fit\n"})}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Decoder Output"})}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"predictions: np.ndarray   # (n_samples,) - class indices\nprobabilities: np.ndarray # (n_samples, n_classes) - softmax confidence\n"})}),"\n",(0,i.jsxs)(r.p,{children:["Shape ",(0,i.jsx)(r.code,{children:"(n_samples, n_channels, n_times)"})," is preserved until model-specific reshaping occurs in the classifier."]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"models",children:"Models"}),"\n",(0,i.jsxs)(r.p,{children:["ModelBase (",(0,i.jsx)(r.code,{children:"src/dendrite/ml/models/base.py"}),") defines the abstract interface for PyTorch architectures designed for time-series neural signals."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Available architectures:"})," Braindecode wrappers (BDEEGNet, BDEEGConformer, BDShallowNet, BDDeep4Net, BDATCNet, BDTCN, BDEEGInception) provide research-grade implementations with published benchmarks. Native models (EEGNet, EEGNetPP, LinearEEG, TransformerEEG) are custom implementations. Classical pipelines (CSP+LDA, CSP+SVM) use sklearn/MNE components with different training paths."]}),"\n",(0,i.jsxs)(r.p,{children:["Neural models have Pydantic configuration schemas defining architecture-specific parameters, validated via ",(0,i.jsx)(r.code,{children:"model_params"})," in ",(0,i.jsx)(r.code,{children:"DecoderConfig"}),". Classical pipelines (CSP+LDA/SVM) use sklearn defaults. Tensor conversion handles numpy to PyTorch to device placement automatically, with model-specific reshaping for time-series vs time-frequency inputs."]}),"\n",(0,i.jsxs)(r.p,{children:["Complete specification: ",(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/dendrite/docs/api/generated/dendrite/ml/models/base",children:"Models API"})})]}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.h2,{id:"metrics",children:"Metrics"}),"\n",(0,i.jsxs)(r.p,{children:["MetricsManager (",(0,i.jsx)(r.code,{children:"src/dendrite/ml/metrics/metrics_manager.py"}),") routes metrics calculations to mode-specific backends. Metrics are computed online during sessions and support post-hoc threshold analysis."]}),"\n",(0,i.jsx)(r.h3,{id:"synchronous-metrics",children:"Synchronous Metrics"}),"\n",(0,i.jsxs)(r.p,{children:["SynchronousMetrics (",(0,i.jsx)(r.code,{children:"src/dendrite/ml/metrics/synchronous_metrics.py"}),") evaluates trial-based classification with discrete epochs."]}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Metric"}),(0,i.jsx)(r.th,{children:"Description"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Prequential Accuracy"})}),(0,i.jsx)(r.td,{children:"Exponentially weighted moving accuracy (forgetting factor: 0.95)"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Confusion Matrix"})}),(0,i.jsx)(r.td,{children:"Per-class prediction counts"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Cohen's Kappa"})}),(0,i.jsx)(r.td,{children:"Agreement beyond chance"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Chance Level"})}),(0,i.jsx)(r.td,{children:"Maximum class proportion (baseline for accuracy)"})]})]})]}),"\n",(0,i.jsx)(r.h3,{id:"asynchronous-metrics",children:"Asynchronous Metrics"}),"\n",(0,i.jsxs)(r.p,{children:["AsynchronousMetrics (",(0,i.jsx)(r.code,{children:"src/dendrite/ml/metrics/asynchronous_metrics.py"}),") evaluates continuous classification using a confusion matrix foundation."]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Window-Based Ground Truth:"}),"\nEach prediction is evaluated against the majority label in its corresponding time window."]}),"\n",(0,i.jsxs)(r.table,{children:[(0,i.jsx)(r.thead,{children:(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.th,{children:"Metric"}),(0,i.jsx)(r.th,{children:"Description"})]})}),(0,i.jsxs)(r.tbody,{children:[(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Balanced Accuracy"})}),(0,i.jsx)(r.td,{children:"Mean of per-class recalls (handles class imbalance)"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Per-class Accuracy"})}),(0,i.jsx)(r.td,{children:"Recall per class (correct / total per class)"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"ITR"})}),(0,i.jsx)(r.td,{children:"Information Transfer Rate (bits/min, Wolpaw formula)"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"FAR/min"})}),(0,i.jsx)(r.td,{children:"False alarm rate per minute (predictions outside trial windows)"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Mean TTD"})}),(0,i.jsx)(r.td,{children:"Mean time-to-detection in ms"})]}),(0,i.jsxs)(r.tr,{children:[(0,i.jsx)(r.td,{children:(0,i.jsx)(r.strong,{children:"Per-class Trials"})}),(0,i.jsx)(r.td,{children:"Trial count per class"})]})]})]}),"\n",(0,i.jsxs)(r.p,{children:[(0,i.jsx)(r.strong,{children:"Background Handling:"})," The ",(0,i.jsx)(r.code,{children:"background_class"})," parameter controls how windows with label ",(0,i.jsx)(r.code,{children:"-1"})," are evaluated. Set to ",(0,i.jsx)(r.code,{children:"None"})," (default) to skip background windows, or set to a class index (e.g., ",(0,i.jsx)(r.code,{children:"0"}),') to evaluate background periods as that class. Useful for paradigms where idle time counts toward metrics (e.g., ErrP where background = "no error").']}),"\n",(0,i.jsx)(r.hr,{}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"Related Documentation:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/dendrite/docs/conceptual/architecture/processing-layer",children:"Processing Layer"})})," - Real-time modes and decoder application"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/dendrite/docs/conceptual/architecture/data-layer",children:"Data Layer"})})," - Data acquisition and storage"]}),"\n"]}),"\n",(0,i.jsx)(r.p,{children:(0,i.jsx)(r.strong,{children:"API References:"})}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/dendrite/docs/api/generated/dendrite/ml/decoders/decoder",children:"Decoders API"})})," - Decoder interface and usage"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:(0,i.jsx)(r.a,{href:"/dendrite/docs/api/generated/dendrite/ml/models/base",children:"Models API"})})," - Model architectures and parameters"]}),"\n"]})]})}function h(e={}){const{wrapper:r}={...(0,c.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>t,x:()=>a});var s=n(6540);const i={},c=s.createContext(i);function t(e){const r=s.useContext(c);return s.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:t(e.components),s.createElement(c.Provider,{value:r},e.children)}}}]);