"use strict";(self.webpackChunkdendrite_docs=self.webpackChunkdendrite_docs||[]).push([[650],{4063:(e,d,s)=>{s.r(d),s.d(d,{assets:()=>t,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>a});const n=JSON.parse('{"id":"api/generated/dendrite/ml/decoders/decoder_schemas","title":"dendrite.ml.decoders.decoder_schemas","description":"Pydantic configuration schemas for Dendrite decoders.","source":"@site/docs/api/generated/dendrite/ml/decoders/decoder_schemas.md","sourceDirName":"api/generated/dendrite/ml/decoders","slug":"/api/generated/dendrite/ml/decoders/decoder_schemas","permalink":"/dendrite/docs/api/generated/dendrite/ml/decoders/decoder_schemas","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"sidebar_label":"decoder_schemas","title":"dendrite.ml.decoders.decoder_schemas"},"sidebar":"tutorialSidebar","previous":{"title":"decoder","permalink":"/dendrite/docs/api/generated/dendrite/ml/decoders/decoder"},"next":{"title":"registry","permalink":"/dendrite/docs/api/generated/dendrite/ml/decoders/registry"}}');var i=s(4848),r=s(8453);const c={sidebar_label:"decoder_schemas",title:"dendrite.ml.decoders.decoder_schemas"},l=void 0,t={},a=[{value:"NeuralNetConfig Objects",id:"neuralnetconfig-objects",level:2},{value:"validate_model_params",id:"validate_model_params",level:4},{value:"get_device",id:"get_device",level:4},{value:"get_model_specific_params",id:"get_model_specific_params",level:4},{value:"DecoderConfig Objects",id:"decoderconfig-objects",level:2},{value:"convert_event_mapping_keys",id:"convert_event_mapping_keys",level:4},{value:"validate_label_mapping_consistency",id:"validate_label_mapping_consistency",level:4},{value:"validate_input_shapes",id:"validate_input_shapes",level:4},{value:"normalize_channel_labels",id:"normalize_channel_labels",level:4},{value:"effective_sample_rate",id:"effective_sample_rate",level:4},{value:"check_compatibility",id:"check_compatibility",level:4}];function o(e){const d={code:"code",h2:"h2",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(d.p,{children:"Pydantic configuration schemas for Dendrite decoders."}),"\n",(0,i.jsx)(d.p,{children:"This module defines the valid parameters for each classifier type using Pydantic models,\nreplacing the scattered manual parameter filtering with automatic validation."}),"\n",(0,i.jsx)(d.h2,{id:"neuralnetconfig-objects",children:"NeuralNetConfig Objects"}),"\n",(0,i.jsx)(d.pre,{children:(0,i.jsx)(d.code,{className:"language-python",children:"class NeuralNetConfig(BaseModel)\n"})}),"\n",(0,i.jsx)(d.p,{children:"Configuration schema for neural network classifiers."}),"\n",(0,i.jsx)(d.p,{children:(0,i.jsx)(d.strong,{children:"Attributes:"})}),"\n",(0,i.jsxs)(d.table,{children:[(0,i.jsx)(d.thead,{children:(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.th,{children:"Field"}),(0,i.jsx)(d.th,{children:"Type"}),(0,i.jsx)(d.th,{children:"Description"})]})}),(0,i.jsxs)(d.tbody,{children:[(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"model_type"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"str"})}),(0,i.jsx)(d.td,{children:"Type of neural network model"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"num_classes"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"int"})}),(0,i.jsx)(d.td,{children:"Number of output classes"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"learning_rate"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float"})}),(0,i.jsx)(d.td,{children:"Learning rate for optimizer"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"device"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"str"})}),(0,i.jsx)(d.td,{children:"Device for model execution (auto/cpu/cuda/mps)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"optimizer_type"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:'Literal["Adam", "AdamW"]'})}),(0,i.jsx)(d.td,{children:"Optimizer type (AdamW has better weight decay, recommended for few-shot)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"epochs"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"int"})}),(0,i.jsx)(d.td,{children:"Number of training epochs"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"batch_size"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"int"})}),(0,i.jsx)(d.td,{children:"Batch size for training"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"validation_split"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float"})}),(0,i.jsx)(d.td,{children:"Validation split ratio"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"use_early_stopping"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"bool"})}),(0,i.jsx)(d.td,{children:"Enable early stopping"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"early_stopping_patience"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"int"})}),(0,i.jsx)(d.td,{children:"Early stopping patience (epochs)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"early_stopping_min_delta"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float"})}),(0,i.jsx)(d.td,{children:"Minimum change to qualify as improvement"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"weight_decay"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float"})}),(0,i.jsx)(d.td,{children:"Weight decay for regularization (use with AdamW)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"max_norm_constraint"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float | None"})}),(0,i.jsx)(d.td,{children:"Max norm for classifier weights (None to disable). Applied after each optimizer step."})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"label_smoothing_factor"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float"})}),(0,i.jsx)(d.td,{children:"Label smoothing factor (0.1 recommended for few-shot, 0 = disabled)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"use_augmentation"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"bool"})}),(0,i.jsx)(d.td,{children:"Enable data augmentation during training"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"aug_strategy"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"str"})}),(0,i.jsx)(d.td,{children:"Augmentation strategy (light/moderate/aggressive)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"use_class_weights"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"bool"})}),(0,i.jsx)(d.td,{children:"Use class weights for imbalanced data"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"class_weight_strategy"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:'Literal["balanced", "inverse", "equal"]'})}),(0,i.jsx)(d.td,{children:"Strategy for calculating class weights"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"use_lr_scheduler"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"bool"})}),(0,i.jsx)(d.td,{children:"Enable learning rate scheduling"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"lr_scheduler_type"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:'Literal["ReduceLROnPlateau", "StepLR", "CosineAnnealingLR", "OneCycleLR"]'})}),(0,i.jsx)(d.td,{children:"Type of LR scheduler (OneCycleLR recommended for few-shot)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"lr_patience"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"int"})}),(0,i.jsx)(d.td,{children:"LR scheduler patience"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"lr_factor"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float"})}),(0,i.jsx)(d.td,{children:"LR reduction factor"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"lr_min"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float"})}),(0,i.jsx)(d.td,{children:"Minimum learning rate"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"lr_step_size"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"int"})}),(0,i.jsx)(d.td,{children:"Step size for StepLR scheduler"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"use_lr_warmup"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"bool"})}),(0,i.jsx)(d.td,{children:"Enable learning rate warmup"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"warmup_epochs"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"int"})}),(0,i.jsx)(d.td,{children:"Number of warmup epochs"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"warmup_start_factor"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float"})}),(0,i.jsx)(d.td,{children:"Starting LR factor during warmup (fraction of base LR)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"onecycle_max_lr"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float | None"})}),(0,i.jsx)(d.td,{children:"Max LR for OneCycleLR (None = 10x learning_rate)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"onecycle_pct_start"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float"})}),(0,i.jsx)(d.td,{children:"Fraction of cycle spent increasing LR"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"mixup_alpha"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float"})}),(0,i.jsx)(d.td,{children:"Beta distribution alpha for mixup (0 = disabled, 0.2 recommended when enabled)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"mixup_type"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:'Literal["mixup", "cutmix", "both"]'})}),(0,i.jsx)(d.td,{children:"Type of mixing augmentation (cutmix better for preserving local structure)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"loss_type"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:'Literal["cross_entropy", "focal"]'})}),(0,i.jsx)(d.td,{children:"Loss function type (focal helps with hard examples)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"focal_gamma"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float"})}),(0,i.jsx)(d.td,{children:"Focal loss gamma (higher = more focus on hard examples)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"use_swa"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"bool"})}),(0,i.jsx)(d.td,{children:"Enable Stochastic Weight Averaging"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"swa_start_epoch"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float"})}),(0,i.jsx)(d.td,{children:"Start SWA at this fraction of total epochs (e.g., 0.75 = last 25%)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"swa_lr"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float | None"})}),(0,i.jsx)(d.td,{children:"SWA learning rate (None = use current LR)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"use_mc_dropout"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"bool"})}),(0,i.jsx)(d.td,{children:"Enable MC Dropout for prediction uncertainty estimation"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"mc_dropout_samples"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"int"})}),(0,i.jsx)(d.td,{children:"Number of MC forward passes for uncertainty estimation"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"model_params"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"dict[str, Any]"})}),(0,i.jsx)(d.td,{children:"Additional model-specific parameters"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"input_shapes"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"dict[str, list[int]] | None"})}),(0,i.jsx)(d.td,{children:"Input shapes for different modalities"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"use_scaler"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"bool"})}),(0,i.jsx)(d.td,{children:"Apply per-channel z-score normalization before model"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"pipeline_steps"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"list[str] | None"})}),(0,i.jsx)(d.td,{children:"Explicit pipeline steps. When None, uses use_scaler to determine steps."})]})]})]}),"\n",(0,i.jsx)(d.h4,{id:"validate_model_params",children:"validate_model_params"}),"\n",(0,i.jsx)(d.pre,{children:(0,i.jsx)(d.code,{className:"language-python",children:'@field_validator("model_params")\n@classmethod\ndef validate_model_params(cls, v, info)\n'})}),"\n",(0,i.jsx)(d.p,{children:"Validate model_params against model-specific config if available."}),"\n",(0,i.jsx)(d.h4,{id:"get_device",children:"get_device"}),"\n",(0,i.jsx)(d.pre,{children:(0,i.jsx)(d.code,{className:"language-python",children:"def get_device() -> torch.device\n"})}),"\n",(0,i.jsx)(d.p,{children:"Get torch device from config."}),"\n",(0,i.jsx)(d.h4,{id:"get_model_specific_params",children:"get_model_specific_params"}),"\n",(0,i.jsx)(d.pre,{children:(0,i.jsx)(d.code,{className:"language-python",children:"def get_model_specific_params() -> dict[str, Any]\n"})}),"\n",(0,i.jsx)(d.p,{children:"Extract parameters specific to the configured model type."}),"\n",(0,i.jsx)(d.p,{children:"Returns model_params dict. Each model's default_parameters (from\nget_model_info) handles its own dropout parameter naming."}),"\n",(0,i.jsxs)(d.p,{children:[(0,i.jsx)(d.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(d.p,{children:"Dictionary of model-specific parameters"}),"\n",(0,i.jsx)(d.h2,{id:"decoderconfig-objects",children:"DecoderConfig Objects"}),"\n",(0,i.jsx)(d.pre,{children:(0,i.jsx)(d.code,{className:"language-python",children:"class DecoderConfig(NeuralNetConfig)\n"})}),"\n",(0,i.jsx)(d.p,{children:"Complete decoder configuration - used for training AND metadata storage."}),"\n",(0,i.jsx)(d.p,{children:(0,i.jsx)(d.strong,{children:"Attributes:"})}),"\n",(0,i.jsxs)(d.table,{children:[(0,i.jsx)(d.thead,{children:(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.th,{children:"Field"}),(0,i.jsx)(d.th,{children:"Type"}),(0,i.jsx)(d.th,{children:"Description"})]})}),(0,i.jsxs)(d.tbody,{children:[(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"event_mapping"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"dict[int, str] | None"})}),(0,i.jsx)(d.td,{children:"Event ID to event name mapping"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"label_mapping"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"dict[str, int] | None"})}),(0,i.jsx)(d.td,{children:"Event name to class index mapping"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"sample_rate"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float | None"})}),(0,i.jsx)(d.td,{children:"Original data sample rate in Hz"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"target_sample_rate"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"float | None"})}),(0,i.jsx)(d.td,{children:"Sample rate after resampling (None = no resampling)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"modality"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"str | None"})}),(0,i.jsx)(d.td,{children:"Signal modality (EEG, EMG, etc.)"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"input_shapes"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"dict[str, list[int]] | None"})}),(0,i.jsx)(d.td,{children:"Input shapes for each modality"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"channel_labels"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"dict[str, list[str]] | None"})}),(0,i.jsx)(d.td,{children:"Channel labels per modality {'eeg': ['Fp1', 'Fp2', ...]}"})]}),(0,i.jsxs)(d.tr,{children:[(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"preprocessing_config"})}),(0,i.jsx)(d.td,{children:(0,i.jsx)(d.code,{children:"PreprocessingConfig | None"})}),(0,i.jsx)(d.td,{children:"Preprocessing config used during training for reproducibility"})]})]})]}),"\n",(0,i.jsx)(d.h4,{id:"convert_event_mapping_keys",children:"convert_event_mapping_keys"}),"\n",(0,i.jsx)(d.pre,{children:(0,i.jsx)(d.code,{className:"language-python",children:'@field_validator("event_mapping", mode="before")\n@classmethod\ndef convert_event_mapping_keys(cls, v)\n'})}),"\n",(0,i.jsx)(d.p,{children:"Convert string keys to integers for JSON compatibility."}),"\n",(0,i.jsx)(d.p,{children:"JSON serialization always converts object keys to strings, but we need\ninteger event IDs for proper decoder functionality."}),"\n",(0,i.jsx)(d.h4,{id:"validate_label_mapping_consistency",children:"validate_label_mapping_consistency"}),"\n",(0,i.jsx)(d.pre,{children:(0,i.jsx)(d.code,{className:"language-python",children:'@field_validator("label_mapping")\n@classmethod\ndef validate_label_mapping_consistency(cls, v, info)\n'})}),"\n",(0,i.jsx)(d.p,{children:"Ensure label_mapping is consistent with num_classes if both are provided."}),"\n",(0,i.jsx)(d.h4,{id:"validate_input_shapes",children:"validate_input_shapes"}),"\n",(0,i.jsx)(d.pre,{children:(0,i.jsx)(d.code,{className:"language-python",children:'@field_validator("input_shapes")\n@classmethod\ndef validate_input_shapes(cls, v)\n'})}),"\n",(0,i.jsx)(d.p,{children:"Validate and normalize input shapes."}),"\n",(0,i.jsx)(d.h4,{id:"normalize_channel_labels",children:"normalize_channel_labels"}),"\n",(0,i.jsx)(d.pre,{children:(0,i.jsx)(d.code,{className:"language-python",children:'@field_validator("channel_labels")\n@classmethod\ndef normalize_channel_labels(cls, v)\n'})}),"\n",(0,i.jsx)(d.p,{children:"Normalize channel_labels keys to lowercase."}),"\n",(0,i.jsx)(d.h4,{id:"effective_sample_rate",children:"effective_sample_rate"}),"\n",(0,i.jsx)(d.pre,{children:(0,i.jsx)(d.code,{className:"language-python",children:"@property\ndef effective_sample_rate() -> float\n"})}),"\n",(0,i.jsx)(d.p,{children:"Get the rate at which model was trained (target if resampled, else original)."}),"\n",(0,i.jsx)(d.h4,{id:"check_compatibility",children:"check_compatibility"}),"\n",(0,i.jsx)(d.pre,{children:(0,i.jsx)(d.code,{className:"language-python",children:"def check_compatibility(system_shapes: dict[str, list[int]],\n                        system_labels: dict[str, list[str]] | None = None,\n                        system_sample_rate: float | None = None) -> list[str]\n"})}),"\n",(0,i.jsx)(d.p,{children:"Check if this decoder is compatible with the given system configuration."}),"\n",(0,i.jsxs)(d.p,{children:[(0,i.jsx)(d.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(d.ul,{children:["\n",(0,i.jsxs)(d.li,{children:[(0,i.jsx)(d.code,{children:"system_shapes"})," - Expected input shapes per modality {modality: [channels, time_samples]}"]}),"\n",(0,i.jsxs)(d.li,{children:[(0,i.jsx)(d.code,{children:"system_labels"})," - Channel labels per modality {modality: ['ch1', 'ch2', ...]}"]}),"\n",(0,i.jsxs)(d.li,{children:[(0,i.jsx)(d.code,{children:"system_sample_rate"})," - System sample rate in Hz"]}),"\n"]}),"\n",(0,i.jsxs)(d.p,{children:[(0,i.jsx)(d.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(d.p,{children:"List of compatibility issues (empty if compatible)"})]})}function h(e={}){const{wrapper:d}={...(0,r.R)(),...e.components};return d?(0,i.jsx)(d,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}},8453:(e,d,s)=>{s.d(d,{R:()=>c,x:()=>l});var n=s(6540);const i={},r=n.createContext(i);function c(e){const d=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(d):{...d,...e}}),[d,e])}function l(e){let d;return d=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),n.createElement(r.Provider,{value:d},e.children)}}}]);