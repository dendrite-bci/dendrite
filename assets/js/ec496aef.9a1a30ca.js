"use strict";(self.webpackChunkdendrite_docs=self.webpackChunkdendrite_docs||[]).push([[184],{8221:(e,i,d)=>{d.r(i),d.d(i,{assets:()=>c,contentTitle:()=>t,default:()=>p,frontMatter:()=>l,metadata:()=>n,toc:()=>o});const n=JSON.parse('{"id":"api/generated/dendrite/ml/decoders/registry","title":"dendrite.ml.decoders.registry","description":"Unified Decoder Registry.","source":"@site/docs/api/generated/dendrite/ml/decoders/registry.md","sourceDirName":"api/generated/dendrite/ml/decoders","slug":"/api/generated/dendrite/ml/decoders/registry","permalink":"/dendrite/docs/api/generated/dendrite/ml/decoders/registry","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"sidebar_label":"registry","title":"dendrite.ml.decoders.registry"},"sidebar":"tutorialSidebar","previous":{"title":"decoder_schemas","permalink":"/dendrite/docs/api/generated/dendrite/ml/decoders/decoder_schemas"},"next":{"title":"models","permalink":"/dendrite/docs/api/generated/dendrite/ml/models/"}}');var r=d(4848),s=d(8453);const l={sidebar_label:"registry",title:"dendrite.ml.decoders.registry"},t=void 0,c={},o=[{value:"build_pipeline",id:"build_pipeline",level:4},{value:"get_available_decoders",id:"get_available_decoders",level:4},{value:"get_decoder_entry",id:"get_decoder_entry",level:4},{value:"get_decoder_capabilities",id:"get_decoder_capabilities",level:4},{value:"check_decoder_compatibility",id:"check_decoder_compatibility",level:4}];function a(e){const i={code:"code",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(i.p,{children:"Unified Decoder Registry."}),"\n",(0,r.jsx)(i.p,{children:"Single source of truth for all decoder types (neural and classical).\nAll decoders use pipeline_builder for consistent sklearn Pipeline architecture."}),"\n",(0,r.jsxs)(i.p,{children:["Architecture:\nModels are defined in ",(0,r.jsx)(i.code,{children:"dendrite.ml.models.MODEL_REGISTRY"}),". This module\nbuilds the ",(0,r.jsx)(i.code,{children:"DECODER_REGISTRY"})," by wrapping each model in a pipeline with\noptional preprocessing steps (scaler, CSP, etc.)."]}),"\n",(0,r.jsx)(i.p,{children:"DECODER_REGISTRY entries contain:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:["'pipeline_builder': Callable that creates sklearn Pipeline from ",(0,r.jsx)(i.code,{children:"config"})]}),"\n",(0,r.jsx)(i.li,{children:"'model_class': The neural network class (for neural decoders only)"}),"\n",(0,r.jsx)(i.li,{children:"'description': Human-readable description"}),"\n",(0,r.jsx)(i.li,{children:"'modalities': Supported input modalities (['eeg'], ['any'], etc.)"}),"\n",(0,r.jsx)(i.li,{children:"'default_steps': Default pipeline step names"}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Extending with Custom Decoders:"}),"\n",(0,r.jsxs)(i.ol,{children:["\n",(0,r.jsx)(i.li,{children:"Add your model to MODEL_REGISTRY (see dendrite.ml.models.registry)"}),"\n",(0,r.jsx)(i.li,{children:"The decoder will be automatically registered with neural pipeline"}),"\n",(0,r.jsx)(i.li,{children:"For classical pipelines, add entry directly to DECODER_REGISTRY"}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Factory Functions:"}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsx)(i.li,{children:"get_available_decoders(): List all registered decoder names"}),"\n",(0,r.jsx)(i.li,{children:"get_decoder_entry(): Get full registry entry for a decoder"}),"\n",(0,r.jsx)(i.li,{children:"get_decoder_capabilities(): Get supported modalities"}),"\n",(0,r.jsx)(i.li,{children:"check_decoder_compatibility(): Validate modality compatibility"}),"\n"]}),"\n",(0,r.jsx)(i.p,{children:"Example:"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-python",children:"from dendrite.ml.decoders.registry import get_available_decoders\nfrom dendrite.ml.decoders.registry import get_decoder_entry\ndecoders = get_available_decoders()\nentry = get_decoder_entry('EEGNet')\npipeline = entry['pipeline_builder'](config)\n"})}),"\n",(0,r.jsx)(i.h4,{id:"build_pipeline",children:"build_pipeline"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-python",children:"def build_pipeline(config, steps: list) -> Pipeline\n"})}),"\n",(0,r.jsx)(i.p,{children:"Build sklearn Pipeline from step list."}),"\n",(0,r.jsx)(i.h4,{id:"get_available_decoders",children:"get_available_decoders"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-python",children:"def get_available_decoders() -> list[str]\n"})}),"\n",(0,r.jsx)(i.p,{children:"Get list of all available decoder types."}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Returns"}),":"]}),"\n",(0,r.jsx)(i.p,{children:"List of decoder type names including neural networks (EEGNet, etc.)\nand classical ML pipelines (CSP+LDA, CSP+SVM)."}),"\n",(0,r.jsx)(i.h4,{id:"get_decoder_entry",children:"get_decoder_entry"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-python",children:"def get_decoder_entry(decoder_type: str) -> dict | None\n"})}),"\n",(0,r.jsx)(i.p,{children:"Get registry entry for a decoder type."}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Arguments"}),":"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"decoder_type"})," - Name of the decoder type to look up."]}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Returns"}),":"]}),"\n",(0,r.jsx)(i.p,{children:"Registry entry dict with keys: pipeline_builder, description,\nmodalities, default_steps. Returns None if not found."}),"\n",(0,r.jsx)(i.h4,{id:"get_decoder_capabilities",children:"get_decoder_capabilities"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-python",children:"def get_decoder_capabilities(decoder_name: str) -> list[str]\n"})}),"\n",(0,r.jsx)(i.p,{children:"Get supported modalities for a decoder type."}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Arguments"}),":"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"decoder_name"})," - Decoder type name (e.g., 'EEGNet', 'CSP+LDA')."]}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Returns"}),":"]}),"\n",(0,r.jsx)(i.p,{children:"List of supported modality names. Returns ['eeg'] for most decoders,\n['any'] for modality-agnostic decoders like LinearEEG."}),"\n",(0,r.jsx)(i.h4,{id:"check_decoder_compatibility",children:"check_decoder_compatibility"}),"\n",(0,r.jsx)(i.pre,{children:(0,r.jsx)(i.code,{className:"language-python",children:"def check_decoder_compatibility(\n        decoder_name: str,\n        selected_modalities: list[str]) -> tuple[bool, list[str]]\n"})}),"\n",(0,r.jsx)(i.p,{children:"Check if selected modalities are compatible with a decoder."}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Arguments"}),":"]}),"\n",(0,r.jsxs)(i.ul,{children:["\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"decoder_name"})," - Decoder type name (e.g., 'EEGNet', 'CSP+LDA')."]}),"\n",(0,r.jsxs)(i.li,{children:[(0,r.jsx)(i.code,{children:"selected_modalities"})," - List of modalities to check (e.g., ['eeg'], ['eeg', 'emg'])."]}),"\n"]}),"\n",(0,r.jsxs)(i.p,{children:[(0,r.jsx)(i.strong,{children:"Returns"}),":"]}),"\n",(0,r.jsx)(i.p,{children:"Tuple of (is_compatible, unsupported_modalities). First element is True\nif all modalities are supported; second element lists any unsupported modalities."})]})}function p(e={}){const{wrapper:i}={...(0,s.R)(),...e.components};return i?(0,r.jsx)(i,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},8453:(e,i,d)=>{d.d(i,{R:()=>l,x:()=>t});var n=d(6540);const r={},s=n.createContext(r);function l(e){const i=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function t(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),n.createElement(s.Provider,{value:i},e.children)}}}]);