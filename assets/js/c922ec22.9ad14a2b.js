"use strict";(self.webpackChunkdendrite_docs=self.webpackChunkdendrite_docs||[]).push([[28],{8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>l});var r=s(6540);const i={},d=r.createContext(i);function c(e){const n=r.useContext(d);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),r.createElement(d.Provider,{value:n},e.children)}},9503:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>t,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"api/generated/dendrite/ml/decoders/decoder","title":"dendrite.ml.decoders.decoder","description":"Decoder for Dendrite applications.","source":"@site/docs/api/generated/dendrite/ml/decoders/decoder.md","sourceDirName":"api/generated/dendrite/ml/decoders","slug":"/api/generated/dendrite/ml/decoders/decoder","permalink":"/dendrite/docs/api/generated/dendrite/ml/decoders/decoder","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"sidebar_label":"decoder","title":"dendrite.ml.decoders.decoder"},"sidebar":"tutorialSidebar","previous":{"title":"decoders","permalink":"/dendrite/docs/api/generated/dendrite/ml/decoders/"},"next":{"title":"decoder_schemas","permalink":"/dendrite/docs/api/generated/dendrite/ml/decoders/decoder_schemas"}}');var i=s(4848),d=s(8453);const c={sidebar_label:"decoder",title:"dendrite.ml.decoders.decoder"},l=void 0,t={},a=[{value:"Decoder Objects",id:"decoder-objects",level:2},{value:"__init__",id:"__init__",level:4},{value:"is_fitted",id:"is_fitted",level:4},{value:"fit",id:"fit",level:4},{value:"get_training_metrics",id:"get_training_metrics",level:4},{value:"get_training_history",id:"get_training_history",level:4},{value:"predict",id:"predict",level:4},{value:"predict_proba",id:"predict_proba",level:4},{value:"save",id:"save",level:4},{value:"get_expected_sample_rate",id:"get_expected_sample_rate",level:4},{value:"predict_sample",id:"predict_sample",level:4},{value:"get_params",id:"get_params",level:4},{value:"set_params",id:"set_params",level:4},{value:"score",id:"score",level:4}];function o(e){const n={code:"code",h2:"h2",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,d.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Decoder for Dendrite applications."}),"\n",(0,i.jsx)(n.p,{children:"Provides a unified interface for neural network and classical ML classifiers\nfor EEG signal classification. This is the primary decoder implementation."}),"\n",(0,i.jsx)(n.p,{children:"Note: This decoder is a pure algorithm implementation. Data management and\nworkflow orchestration should be handled by the mode that uses this decoder."}),"\n",(0,i.jsx)(n.h2,{id:"decoder-objects",children:"Decoder Objects"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class Decoder(BaseEstimator, ClassifierMixin)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Primary decoder for EEG classification."}),"\n",(0,i.jsx)(n.p,{children:"Wraps neural network and classical ML classifiers in an sklearn-compatible\ninterface for training, prediction, and cross-validation."}),"\n",(0,i.jsx)(n.p,{children:"Features:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Neural network classifiers (EEGNet, TransformerEEG, LinearEEG, etc.)"}),"\n",(0,i.jsx)(n.li,{children:"Classical ML pipelines (CSP+LDA, CSP+SVM, etc.)"}),"\n",(0,i.jsx)(n.li,{children:"sklearn-compatible interface (works with cross_val_score, GridSearchCV, MOABB)"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"__init__",children:"__init__"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def __init__(config: DecoderConfig)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Initialize decoder with configuration."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"config"})," - DecoderConfig with model type, input shape, and training params"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Example"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"config = DecoderConfig(\nmodel_type='EEGNet',\nnum_classes=3,\ninput_shape=(32, 250),  # (channels, times)\nepochs=200,"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"event_mapping=\\{1"})," - 'left', 2: 'right'},"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"label_mapping=\\{'left'"})," - 0, 'right': 1}\n)\ndecoder = Decoder(config)"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"is_fitted",children:"is_fitted"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"@property\ndef is_fitted() -> bool\n"})}),"\n",(0,i.jsx)(n.p,{children:"Check if the decoder is fitted and ready."}),"\n",(0,i.jsx)(n.h4,{id:"fit",children:"fit"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def fit(X: np.ndarray, y: np.ndarray, epoch_callback=None) -> "Decoder"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Train the decoder on provided data."}),"\n",(0,i.jsx)(n.p,{children:"For cross-validation, use sklearn's cross_val_score() externally:\nscores = cross_val_score(decoder, X, y, cv=5)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"X"})," - Training data with shape (n_samples, n_channels, n_times)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"y"})," - Training labels with shape (n_samples,)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"epoch_callback"})," - Optional callback invoked after each training epoch."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Signature"})," - callback(epoch, total_epochs, train_loss, train_acc,\nval_loss, val_acc) where val_loss and val_acc are None if no\nvalidation set is used."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsxs)(n.p,{children:["Self for method chaining (sklearn compatible). After training,\n",(0,i.jsx)(n.code,{children:"training_metrics"})," attribute is populated for neural models with:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"'history': Dict with 'train_loss', 'train_acc', 'val_loss', 'val_acc' lists"}),"\n",(0,i.jsx)(n.li,{children:"'final_train_acc', 'final_val_acc': Final epoch accuracies"}),"\n",(0,i.jsx)(n.li,{children:"'epochs_completed': Number of epochs trained"}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"get_training_metrics",children:"get_training_metrics"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_training_metrics() -> dict[str, Any] | None\n"})}),"\n",(0,i.jsx)(n.p,{children:"Get training metrics from the last training session."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"Training metrics if available, None otherwise"}),"\n",(0,i.jsx)(n.h4,{id:"get_training_history",children:"get_training_history"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_training_history() -> dict[str, Any] | None\n"})}),"\n",(0,i.jsx)(n.p,{children:"Get detailed training history (loss/accuracy curves) if available."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"Training history if available, None otherwise"}),"\n",(0,i.jsx)(n.h4,{id:"predict",children:"predict"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def predict(X: np.ndarray) -> int | np.ndarray\n"})}),"\n",(0,i.jsx)(n.p,{children:"Predict class labels."}),"\n",(0,i.jsx)(n.p,{children:"For Dendrite applications, consider using predict_sample() to also get confidence."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"X"})," - Input data with shape (n_samples, n_channels, n_times) or (n_channels, n_times)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"Predicted class(es). Single int for single sample, array of ints for batch."}),"\n",(0,i.jsx)(n.h4,{id:"predict_proba",children:"predict_proba"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def predict_proba(X: np.ndarray) -> np.ndarray\n"})}),"\n",(0,i.jsx)(n.p,{children:"Predict class probabilities."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"X"})," - Input data with shape (n_samples, n_channels, n_times) or (n_channels, n_times)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"Class probabilities with shape (n_samples, n_classes)"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Raises"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"RuntimeError"})," - If model is not fitted or prediction fails."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"save",children:"save"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def save(file_identifier: str, study_name: str | None = None) -> str\n"})}),"\n",(0,i.jsx)(n.p,{children:"Save complete decoder (pipeline + config + metadata) to disk."}),"\n",(0,i.jsx)(n.p,{children:"Uses format: .json (metadata) + .pt (neural state) or .joblib (classical pipeline).\nNeural models use torch.save for state_dict to handle parametrized modules."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"file_identifier"})," - Unique identifier for the decoder file."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"study_name"})," - Study name for study-scoped storage. If None, uses\nglobal decoders directory."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"Path to the saved JSON metadata file."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Raises"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ValueError"})," - If file_identifier is empty or decoder is not fitted."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"get_expected_sample_rate",children:"get_expected_sample_rate"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_expected_sample_rate() -> float\n"})}),"\n",(0,i.jsx)(n.p,{children:"Get the rate at which model was trained (for online validation)."}),"\n",(0,i.jsx)(n.h4,{id:"predict_sample",children:"predict_sample"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def predict_sample(X: np.ndarray) -> tuple[int, float]\n"})}),"\n",(0,i.jsx)(n.p,{children:"Primary prediction interface for BMI applications."}),"\n",(0,i.jsx)(n.p,{children:"Returns both prediction and confidence for a single sample."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"X"})," - Single sample with shape (n_channels, n_times) or (1, n_channels, n_times)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"Tuple of (prediction, confidence)"}),"\n",(0,i.jsx)(n.h4,{id:"get_params",children:"get_params"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def get_params(deep: bool = True) -> dict[str, Any]\n"})}),"\n",(0,i.jsx)(n.p,{children:"Get parameters for sklearn compatibility."}),"\n",(0,i.jsx)(n.p,{children:"Required for cross_val_score, GridSearchCV, clone(), etc."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"deep"})," - If True, return nested parameters (ignored, config is atomic)"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"Parameter dict with 'config' key containing DecoderConfig"}),"\n",(0,i.jsx)(n.h4,{id:"set_params",children:"set_params"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def set_params(**params) -> "Decoder"\n'})}),"\n",(0,i.jsx)(n.p,{children:"Set parameters for sklearn compatibility."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"**params"})," - Parameters to set. Supports 'config' for full config replacement."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"Self for method chaining."}),"\n",(0,i.jsx)(n.h4,{id:"score",children:"score"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def score(X: np.ndarray, y: np.ndarray) -> float\n"})}),"\n",(0,i.jsx)(n.p,{children:"Return accuracy score for sklearn compatibility."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Arguments"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"X"})," - Test samples with shape (n_samples, n_channels, n_times)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"y"})," - True labels"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Returns"}),":"]}),"\n",(0,i.jsx)(n.p,{children:"Accuracy score (fraction of correct predictions)"})]})}function h(e={}){const{wrapper:n}={...(0,d.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(o,{...e})}):o(e)}}}]);