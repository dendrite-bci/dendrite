"use strict";(self.webpackChunkdendrite_docs=self.webpackChunkdendrite_docs||[]).push([[570],{2742:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>u,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"guides/synchronous-mode","title":"Synchronous Mode","description":"Synchronous mode segments data around discrete events, collecting labeled epochs for classifier training and evaluation. Use it for motor imagery with cued trials, P300 oddball paradigms, or any protocol with known event timing.","source":"@site/docs/guides/synchronous-mode.md","sourceDirName":"guides","slug":"/guides/synchronous-mode","permalink":"/dendrite/docs/guides/synchronous-mode","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"id":"synchronous-mode","title":"Synchronous Mode","sidebar_label":"Synchronous Mode"},"sidebar":"tutorialSidebar","previous":{"title":"Data Acquisition","permalink":"/dendrite/docs/guides/data-acquisition"},"next":{"title":"Asynchronous Mode","permalink":"/dendrite/docs/guides/asynchronous-mode"}}');var s=o(4848),i=o(8453);const r={id:"synchronous-mode",title:"Synchronous Mode",sidebar_label:"Synchronous Mode"},d="Synchronous Mode",a={},c=[{value:"Configuration",id:"configuration",level:2},{value:"Online Training",id:"online-training",level:2},{value:"Output",id:"output",level:2},{value:"See Also",id:"see-also",level:2}];function l(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"synchronous-mode",children:"Synchronous Mode"})}),"\n",(0,s.jsx)(n.p,{children:"Synchronous mode segments data around discrete events, collecting labeled epochs for classifier training and evaluation. Use it for motor imagery with cued trials, P300 oddball paradigms, or any protocol with known event timing."}),"\n",(0,s.jsx)(n.h2,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsx)(n.p,{children:"Add a synchronous mode from the Modes section and open its configuration dialog."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Epoch timing"})," defines the window extracted around each event. Set the start offset (typically 0.0s) and end offset (1.0-2.0s depending on paradigm)."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Event mappings"}),' connect event codes to class labels. Map event ID 1 to "left", ID 2 to "right", etc. Unmapped codes are ignored.']}),"\n",(0,s.jsx)(n.h2,{id:"online-training",children:"Online Training"}),"\n",(0,s.jsx)(n.p,{children:"Enable training to update the decoder as epochs accumulate. Select a model type (EEGNet, CSP+LDA) and set a training interval. An interval of 10 retrains after every 10 new epochs."}),"\n",(0,s.jsxs)(n.p,{children:["Trained models save every 30 seconds. Asynchronous modes configured with ",(0,s.jsx)(n.code,{children:"decoder_source: sync_mode"})," receive these updates automatically."]}),"\n",(0,s.jsx)(n.h2,{id:"output",children:"Output"}),"\n",(0,s.jsx)(n.p,{children:"Each event triggers epoch extraction and prediction. The mode outputs per-trial classification with confidence and tracks accuracy, kappa, and F1. ERP visualization shows averaged waveforms per event type."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "type": "prediction",\n  "mode_name": "sync_1",\n  "mode_type": "synchronous",\n  "data": {\n    "prediction": 1,\n    "event_name": "left",\n    "true_event": "left",\n    "confidence": 0.85\n  },\n  "data_timestamp": 1705312345.123\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"/dendrite/docs/guides/send-events",children:"Send Events"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>r,x:()=>d});var t=o(6540);const s={},i=t.createContext(s);function r(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);